{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.20;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC2612 standard as defined in the EIP.\r\n *\r\n * Adds the {permit} method, which can be used to change one's\r\n * {IERC20-allowance} without having to send a transaction, by signing a\r\n * message. This allows users to spend tokens without having to hold Ether.\r\n *\r\n * See https://eips.ethereum.org/EIPS/eip-2612.\r\n */\r\ninterface IERC2612 {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be `address(0)`.\r\n     * - `spender` cannot be `address(0)`.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use `owner`'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by EIP712.\r\n     */\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n"
    },
    "contracts/interfaces/IERC667.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.20;\n\ninterface ITransferReceiver {\n    function onTokenTransfer(\n        address,\n        uint,\n        bytes calldata\n    ) external returns (bool);\n}\n\ninterface IApprovalReceiver {\n    function onTokenApproval(\n        address,\n        uint,\n        bytes calldata\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(\r\n        address sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint256\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IUniswapV2ERC20} from \"./IUniswapV2ERC20.sol\";\r\n\r\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function getPredicts(\r\n        bool _switch\r\n    ) external view returns (uint256 _price0Predict, uint256 _price1Predict);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(\r\n        address to\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n\r\n    function updateFee(bool _feeOn, uint256 feeAmount) external;\r\n\r\n    function updatePredict(uint256 _predict0, uint256 _predict1) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\nimport {IUniswapV2Router01} from \"./IUniswapV2Router01.sol\";\r\n\r\ninterface IUniswapV2Router is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\n//solhint-disable func-name-mixedcase\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external view returns (address);\r\n\r\n    function WETH() external view returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountOut);\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint256 amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint256 amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Copyright (C) 2015, 2016, 2017 Dapphub\r\n// Adapted by Ethereum Community 2021\r\npragma solidity ^0.8.22;\r\n\r\nimport {IERC20, IERC2612} from \"./IERC20.sol\";\r\n\r\ninterface IERC3156FlashBorrower {\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32);\r\n}\r\n\r\ninterface IERC3156FlashLender {\r\n    /**\r\n     * @dev The amount of currency available to be lended.\r\n     * @param token The loan currency.\r\n     * @return The amount of `token` that can be borrowed.\r\n     */\r\n    function maxFlashLoan(address token) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev The fee to be charged for a given loan.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\r\n     */\r\n    function flashFee(\r\n        address token,\r\n        uint256 amount\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Initiate a flash loan.\r\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     */\r\n    function flashLoan(\r\n        IERC3156FlashBorrower receiver,\r\n        address token,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n\r\n/// @dev Wrapped ETH v10 (WETH10) is an ETH (ETH) ERC-20 wrapper. You can `deposit` ETH and obtain a WETH10 balance which can then be operated as an ERC-20 token. You can\r\n/// `withdraw` ETH from WETH10, which will then burn WETH10 token in your wallet. The amount of WETH10 token in any wallet is always identical to the\r\n/// balance of ETH deposited minus the ETH withdrawn with that specific wallet.\r\ninterface IWETH10 is IERC20, IERC2612, IERC3156FlashLender {\r\n    /// @dev Returns current amount of flash-minted WETH10 token.\r\n    function flashMinted() external view returns (uint256);\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\r\n    function deposit() external payable;\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to `to` account.\r\n    function depositTo(address to) external payable;\r\n\r\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to the same.\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` balance of WETH10 token.\r\n    function withdraw(uint256 value) external;\r\n\r\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to account (`to`).\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` balance of WETH10 token.\r\n    function withdrawTo(address payable to, uint256 value) external;\r\n\r\n    /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ETH to account (`to`).\r\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\r\n    /// unless allowance is set to `type(uint256).max`\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from account (`from`).\r\n    /// Requirements:\r\n    ///   - `from` account must have at least `value` balance of WETH10 token.\r\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\r\n    function withdrawFrom(\r\n        address from,\r\n        address payable to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance,\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function depositToAndCall(\r\n        address to,\r\n        bytes calldata data\r\n    ) external payable returns (bool);\r\n\r\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token,\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// Emits {Approval} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// For more information on {approveAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n\r\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`),\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` WETH10 token.\r\n    /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function transferAndCall(\r\n        address to,\r\n        uint value,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.22;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(\n        bytes32[] memory proof,\n        bytes32 leaf\n    ) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 leaf\n    ) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen - 1 != totalHashes) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen\n                ? leaves[leafPos++]\n                : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen - 1 != totalHashes) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen\n                ? leaves[leafPos++]\n                : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(\n        bytes32 a,\n        bytes32 b\n    ) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeApprove: approve failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeTransfer: transfer failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::transferFrom: transferFrom failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(\r\n            success,\r\n            \"TransferHelper::safeTransferETH: ETH transfer failed\"\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\n//solhint-disable reason-string\r\n\r\nimport {IUniswapV2Pair} from \"../interfaces/IUniswapV2Pair.sol\";\r\n\r\nlibrary UniswapV2Library {\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            bytes1(0xff),\r\n                            factory,\r\n                            keccak256(abi.encodePacked(token0, token1)),\r\n                            hex\"443533a897cfad2762695078bf6ee9b78b4edcda64ec31e1c83066cee4c90a7e\" // init code hash\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\r\n            pairFor(factory, tokenA, tokenB)\r\n        ).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0\r\n            ? (reserve0, reserve1)\r\n            : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) internal pure returns (uint256 amountB) {\r\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\r\n        require(\r\n            reserveA > 0 && reserveB > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        amountB = (amountA * reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 amountInWithFee = amountIn * 997;\r\n        uint256 numerator = amountInWithFee * reserveOut;\r\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountIn) {\r\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 numerator = reserveIn * amountOut * 1000;\r\n        uint256 denominator = (reserveOut - amountOut) * 997;\r\n        amountIn = numerator / denominator + 1;\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        address factory,\r\n        uint256 amountIn,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\r\n                factory,\r\n                path[i],\r\n                path[i + 1]\r\n            );\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(\r\n        address factory,\r\n        uint256 amountOut,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint256 i = path.length - 1; i > 0; i--) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\r\n                factory,\r\n                path[i - 1],\r\n                path[i]\r\n            );\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    //solhint-disable-next-line state-visibility\r\n    uint224 constant Q112 = 2 ** 112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n"
    },
    "contracts/test/ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\nimport {UniswapV2ERC20} from \"../UniswapV2ERC20.sol\";\r\n\r\ncontract ERC20 is UniswapV2ERC20 {\r\n    constructor(uint256 _totalSupply) {\r\n        _mint(msg.sender, _totalSupply);\r\n    }\r\n}\r\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {UniswapV2ERC20} from \"../UniswapV2ERC20.sol\";\n\ncontract MockERC20 is UniswapV2ERC20 {\n    constructor(uint256 _totalSupply) {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "contracts/test/MockERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.6;\n\nimport {ITransferReceiver, IApprovalReceiver} from \"../interfaces/IERC667.sol\";\n\n/**\n * @title Mock ERC-677 Receiver\n * @author solace.fi\n * @notice A mock contract that receives notice of token events per the [`ERC-677` standard](https://github.com/ethereum/EIPs/issues/677).\n */\ncontract MockERC677Receiver is ITransferReceiver, IApprovalReceiver {\n    /// @notice Emitted when tokens are transferred.\n    event TokenTransferred(address from, uint256 amount, bytes data);\n    /// @notice Emitted when tokens are approved.\n    event TokenApproved(address from, uint256 amount, bytes data);\n\n    /**\n     * @notice Called by the token contract after tokens are transferred from another account to this contract.\n     * @param from The token sender.\n     * @param amount The amount of tokens transferred.\n     * @param data Free form calldata.\n     * @return success True if the execution was successful.\n     */\n    function onTokenTransfer(\n        address from,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool success) {\n        emit TokenTransferred(from, amount, data);\n        return true;\n    }\n\n    /**\n     * @notice Called by the token contract after tokens are approved from another account to this contract.\n     * @param from The token sender.\n     * @param amount The amount of tokens approved.\n     * @param data Free form calldata.\n     * @return success True if the execution was successful.\n     */\n    function onTokenApproval(\n        address from,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool success) {\n        emit TokenTransferred(from, amount, data);\n        return true;\n    }\n}\n"
    },
    "contracts/test/MockFaultyReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.6;\n\n/**\n * @title Mock Faulty Receiver\n * @author solace.fi\n * @notice A contract that throws if sent ETH.\n */\ncontract MockFaultyReceiver {\n    /**\n     * @notice Fallback function to allow contract to receive **ETH**.\n     */\n    receive() external payable {\n        revert(\"get stickbugged\");\n    }\n\n    /**\n     * @notice Fallback function to allow contract to receive **ETH**.\n     */\n    fallback() external payable {\n        revert(\"get stickbugged\");\n    }\n\n    /**\n     * @notice Forwards a call to another contract.\n     * Do not use in production.\n     * @param to Contract to call.\n     * @param data Data to send.\n     */\n    function forwardCall(\n        address payable to,\n        bytes calldata data\n    ) external payable {\n        (bool success, ) = to.call{value: msg.value}(data);\n        require(success, \"could not forward call\");\n    }\n}\n"
    },
    "contracts/test/RouterEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IUniswapV2Router01} from \"../interfaces/IUniswapV2Router01.sol\";\n\ncontract RouterEventEmitter {\n    event Amounts(uint256[] amounts);\n\n    receive() external payable {}\n\n    function swapExactTokensForTokens(\n        address router,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapExactTokensForTokens.selector,\n                amountIn,\n                amountOutMin,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapTokensForExactTokens(\n        address router,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapTokensForExactTokens.selector,\n                amountOut,\n                amountInMax,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapExactETHForTokens(\n        address router,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapExactETHForTokens.selector,\n                amountOutMin,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapTokensForExactETH(\n        address router,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapTokensForExactETH.selector,\n                amountOut,\n                amountInMax,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapExactTokensForETH(\n        address router,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapExactTokensForETH.selector,\n                amountIn,\n                amountOutMin,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapETHForExactTokens(\n        address router,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapETHForExactTokens.selector,\n                amountOut,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.17;\n\nimport {UniswapV2ERC20} from \"../UniswapV2ERC20.sol\";\n\ncontract ERC20 is UniswapV2ERC20 {\n    constructor(uint256 _totalSupply) {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    },
    "contracts/test/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad, \"\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad, \"\");\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint256).max\n        ) {\n            require(allowance[src][msg.sender] >= wad, \"\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/UniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\nimport {IUniswapV2ERC20} from \"./interfaces/IUniswapV2ERC20.sol\";\r\n\r\ncontract UniswapV2ERC20 is IUniswapV2ERC20 {\r\n    string public constant override name = \"Uniswap V2\";\r\n    string public constant override symbol = \"UNI-V2\";\r\n    uint8 public constant override decimals = 18;\r\n    uint256 public override totalSupply;\r\n    mapping(address => uint256) public override balanceOf;\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n\r\n    bytes32 public override DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint256) public override nonces;\r\n\r\n    constructor() {\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                ),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\"1\")),\r\n                block.chainid,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply += value;\r\n        balanceOf[to] += value;\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint256 value) internal {\r\n        balanceOf[from] -= value;\r\n        totalSupply -= value;\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 value) private {\r\n        balanceOf[from] -= value;\r\n        balanceOf[to] += value;\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n    ) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    ) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint256).max) {\r\n            allowance[from][msg.sender] -= value;\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override {\r\n        require(deadline >= block.timestamp, \"UniswapV2: EXPIRED\");\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        PERMIT_TYPEHASH,\r\n                        owner,\r\n                        spender,\r\n                        value,\r\n                        nonces[owner]++,\r\n                        deadline\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(\r\n            recoveredAddress != address(0) && recoveredAddress == owner,\r\n            \"UniswapV2: INVALID_SIGNATURE\"\r\n        );\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/UniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\nimport {IUniswapV2Factory} from \"./interfaces/IUniswapV2Factory.sol\";\r\nimport {IUniswapV2Pair} from \"./interfaces/IUniswapV2Pair.sol\";\r\nimport {UniswapV2Pair} from \"./UniswapV2Pair.sol\";\r\n\r\ncontract UniswapV2Factory is IUniswapV2Factory {\r\n    bytes32 public constant PAIR_HASH =\r\n        keccak256(type(UniswapV2Pair).creationCode);\r\n\r\n    address public override feeTo;\r\n    address public override feeToSetter;\r\n\r\n    mapping(address => mapping(address => address)) public override getPair;\r\n    address[] public override allPairs;\r\n\r\n    constructor(address _feeToSetter) {\r\n        feeToSetter = _feeToSetter;\r\n    }\r\n\r\n    function allPairsLength() external view override returns (uint256) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external override returns (address pair) {\r\n        require(tokenA != tokenB, \"UniswapV2: IDENTICAL_ADDRESSES\");\r\n        (address token0, address token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2: ZERO_ADDRESS\");\r\n        require(\r\n            getPair[token0][token1] == address(0),\r\n            \"UniswapV2: PAIR_EXISTS\"\r\n        ); // single check is sufficient\r\n\r\n        pair = address(\r\n            new UniswapV2Pair{\r\n                salt: keccak256(abi.encodePacked(token0, token1))\r\n            }()\r\n        );\r\n        IUniswapV2Pair(pair).initialize(token0, token1);\r\n        getPair[token0][token1] = pair;\r\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\r\n        allPairs.push(pair);\r\n        emit PairCreated(token0, token1, pair, allPairs.length);\r\n    }\r\n\r\n    function setFeeTo(address _feeTo) external override {\r\n        require(msg.sender == feeToSetter, \"UniswapV2: FORBIDDEN\");\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    function setFeeToSetter(address _feeToSetter) external override {\r\n        require(msg.sender == feeToSetter, \"UniswapV2: FORBIDDEN\");\r\n        feeToSetter = _feeToSetter;\r\n    }\r\n}\r\n"
    },
    "contracts/UniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IUniswapV2Pair} from \"./interfaces/IUniswapV2Pair.sol\";\nimport {UniswapV2ERC20} from \"./UniswapV2ERC20.sol\";\nimport {Math} from \"./libraries/Math.sol\";\nimport {UQ112x112} from \"./libraries/UQ112x112.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IUniswapV2Factory} from \"./interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Callee} from \"./interfaces/IUniswapV2Callee.sol\";\n\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {\n    using UQ112x112 for uint224;\n\n    uint256 public constant override MINIMUM_LIQUIDITY = 10 ** 3;\n\n    address public override factory;\n    address public override token0;\n    address public override token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint256 private price0Predict; // uses single storage slot, accessible via getPredicts\n    uint256 private price1Predict; // uses single storage slot, accessible via getPredicts\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public override price0CumulativeLast;\n    uint256 public override price1CumulativeLast;\n    uint256 public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, \"UniswapV2: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves()\n        public\n        view\n        override\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function getPredicts(\n        bool _switch\n    )\n        public\n        view\n        override\n        returns (uint256 _price0Predict, uint256 _price1Predict)\n    {\n        if (_switch) {\n            _price0Predict = price0Predict;\n            _price1Predict = price1Predict;\n        } else return (0, 0);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"UniswapV2: TRANSFER_FAILED\"\n        );\n    }\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external override {\n        require(msg.sender == factory, \"UniswapV2: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n        price0Predict = 1; // min price prediction\n        price1Predict = 1;\n    }\n\n    function updateFee(bool _feeOn, uint256 feeAmount) external override lock {\n        address feeTo = IUniswapV2Factory(factory).feeToSetter();\n        require(msg.sender == feeTo, \"UniswapV2: FORBIDDEN\");\n        if (_feeOn) {\n            _mint(msg.sender, feeAmount);\n        } else {\n            (uint256 _reserve0, uint256 _reserve1) = getPredicts(false); // gas savings\n            uint256 balance0 = IERC20(token0).balanceOf(address(this));\n            uint256 balance1 = IERC20(token1).balanceOf(address(this));\n            _update(\n                balance0,\n                balance1,\n                uint112(_reserve0),\n                uint112(_reserve1),\n                false\n            );\n        }\n    }\n\n    function updatePredict(\n        uint256 _predict0,\n        uint256 _predict1\n    ) external override lock {\n        address feeTo = IUniswapV2Factory(factory).feeToSetter();\n        require(msg.sender == feeTo, \"UniswapV2: FORBIDDEN\");\n        price0Predict = _predict0;\n        price1Predict = _predict1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1,\n        bool checkedReserve\n    ) private {\n        if (checkedReserve) {\n            require(\n                balance0 <= type(uint112).max && balance1 <= type(uint112).max,\n                \"UniswapV2: OVERFLOW\"\n            );\n\n            uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n            unchecked {\n                uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n                if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n                    // * never overflows, and + overflow is desired\n                    price0CumulativeLast +=\n                        uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                        timeElapsed;\n                    price1CumulativeLast +=\n                        uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                        timeElapsed;\n                }\n            }\n            reserve0 = uint112(balance0);\n            reserve1 = uint112(balance1);\n            blockTimestampLast = blockTimestamp;\n        } else {\n            // optimistically transfer tokens to factory\n            uint256 amount0 = balance0 - _reserve0;\n            if (amount0 > 0) _safeTransfer(token0, msg.sender, amount0);\n            uint256 amount1 = balance1 - _reserve1;\n            if (amount1 > 0) _safeTransfer(token1, msg.sender, amount1);\n        }\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private returns (bool feeOn) {\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint256(_reserve0) * _reserve1);\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply * (rootK - rootKLast);\n                    uint256 denominator = rootK * 5 + rootKLast;\n                    uint256 liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(\n        address to\n    ) external override lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(\n                (amount0 * _totalSupply) / _reserve0,\n                (amount1 * _totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1, true);\n        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(\n        address to\n    ) external override lock returns (uint256 amount0, uint256 amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            amount0 > 0 && amount1 > 0,\n            \"UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1, true);\n        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external override lock {\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            amount0Out < _reserve0 && amount1Out < _reserve1,\n            \"UniswapV2: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(\n            price0Predict < balance0 - amount0Out &&\n                price1Predict < balance1 - amount1Out,\n            \"UniswapV2: INSUFFICIENT_PREDICT_AMOUNT\"\n        );\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"UniswapV2: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0)\n                IUniswapV2Callee(to).uniswapV2Call(\n                    msg.sender,\n                    amount0Out,\n                    amount1Out,\n                    data\n                );\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"UniswapV2: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0 * 1000 - amount0In * 3;\n            uint256 balance1Adjusted = balance1 * 1000 - amount1In * 3;\n            require(\n                balance0Adjusted * balance1Adjusted >=\n                    uint256(_reserve0) * _reserve1 * 1e6,\n                \"UniswapV2: K\"\n            );\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1, true);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external override lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(\n            _token0,\n            to,\n            IERC20(_token0).balanceOf(address(this)) - reserve0\n        );\n        _safeTransfer(\n            _token1,\n            to,\n            IERC20(_token1).balanceOf(address(this)) - reserve1\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external override lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1,\n            true\n        );\n    }\n}\n"
    },
    "contracts/UniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.22;\r\n\r\nimport {IUniswapV2Factory} from \"./interfaces/IUniswapV2Factory.sol\";\r\nimport {IUniswapV2Router} from \"./interfaces/IUniswapV2Router.sol\";\r\nimport {IUniswapV2Pair} from \"./interfaces/IUniswapV2Pair.sol\";\r\nimport {IERC20} from \"./interfaces/IERC20.sol\";\r\nimport {IWETH10} from \"./interfaces/IWETH.sol\";\r\n\r\nimport {TransferHelper} from \"./libraries/TransferHelper.sol\";\r\nimport {UniswapV2Library} from \"./libraries/UniswapV2Library.sol\";\r\n\r\ncontract UniswapV2Router is IUniswapV2Router {\r\n    //solhint-disable-next-line immutable-vars-naming\r\n    address public immutable override factory;\r\n    address public immutable override WETH;\r\n\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, \"UniswapV2Router: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH) {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin\r\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(\r\n            factory,\r\n            tokenA,\r\n            tokenB\r\n        );\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint256 amountBOptimal = UniswapV2Library.quote(\r\n                amountADesired,\r\n                reserveA,\r\n                reserveB\r\n            );\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(\r\n                    amountBOptimal >= amountBMin,\r\n                    \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\r\n                );\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint256 amountAOptimal = UniswapV2Library.quote(\r\n                    amountBDesired,\r\n                    reserveB,\r\n                    reserveA\r\n                );\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(\r\n                    amountAOptimal >= amountAMin,\r\n                    \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\r\n                );\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256 amountA, uint256 amountB, uint256 liquidity)\r\n    {\r\n        (amountA, amountB) = _addLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            amountADesired,\r\n            amountBDesired,\r\n            amountAMin,\r\n            amountBMin\r\n        );\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IUniswapV2Pair(pair).mint(to);\r\n    }\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)\r\n    {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WETH,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWETH10(WETH).deposit{value: amountETH}();\r\n        assert(IWETH10(WETH).transfer(pair, amountETH));\r\n        liquidity = IUniswapV2Pair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH)\r\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256 amountA, uint256 amountB)\r\n    {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\r\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(to);\r\n        (address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0\r\n            ? (amount0, amount1)\r\n            : (amount1, amount0);\r\n        require(\r\n            amountA >= amountAMin,\r\n            \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\r\n        );\r\n        require(\r\n            amountB >= amountBMin,\r\n            \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\r\n        );\r\n    }\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256 amountToken, uint256 amountETH)\r\n    {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWETH10(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external virtual override returns (uint256 amountA, uint256 amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        uint256 value = approveMax ? type(uint256).max : liquidity;\r\n        IUniswapV2Pair(pair).permit(\r\n            msg.sender,\r\n            address(this),\r\n            value,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        (amountA, amountB) = removeLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            liquidity,\r\n            amountAMin,\r\n            amountBMin,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        returns (uint256 amountToken, uint256 amountETH)\r\n    {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint256 value = approveMax ? type(uint256).max : liquidity;\r\n        IUniswapV2Pair(pair).permit(\r\n            msg.sender,\r\n            address(this),\r\n            value,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        (amountToken, amountETH) = removeLiquidityETH(\r\n            token,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\r\n        (, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(\r\n            token,\r\n            to,\r\n            IERC20(token).balanceOf(address(this))\r\n        );\r\n        IWETH10(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external virtual override returns (uint256 amountETH) {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint256 value = approveMax ? type(uint256).max : liquidity;\r\n        IUniswapV2Pair(pair).permit(\r\n            msg.sender,\r\n            address(this),\r\n            value,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            token,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(\r\n        uint256[] memory amounts,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\r\n            uint256 amountOut = amounts[i + 1];\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\r\n                ? (uint256(0), amountOut)\r\n                : (amountOut, uint256(0));\r\n            address to = i < path.length - 2\r\n                ? UniswapV2Library.pairFor(factory, output, path[i + 2])\r\n                : _to;\r\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output))\r\n                .swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256[] memory amounts)\r\n    {\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(\r\n            amounts[amounts.length - 1] >= amountOutMin,\r\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n            amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256[] memory amounts)\r\n    {\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(\r\n            amounts[0] <= amountInMax,\r\n            \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n            amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\r\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\r\n        require(\r\n            amounts[amounts.length - 1] >= amountOutMin,\r\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        IWETH10(WETH).deposit{value: amounts[0]}();\r\n        assert(\r\n            IWETH10(WETH).transfer(\r\n                UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n                amounts[0]\r\n            )\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(\r\n            amounts[0] <= amountInMax,\r\n            \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n            amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH10(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(\r\n            amounts[amounts.length - 1] >= amountOutMin,\r\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n            amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH10(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint256[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(\r\n            amounts[0] <= msg.value,\r\n            \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\"\r\n        );\r\n        IWETH10(WETH).deposit{value: amounts[0]}();\r\n        assert(\r\n            IWETH10(WETH).transfer(\r\n                UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n                amounts[0]\r\n            )\r\n        );\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0])\r\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\r\n            IUniswapV2Pair pair = IUniswapV2Pair(\r\n                UniswapV2Library.pairFor(factory, input, output)\r\n            );\r\n            uint256 amountInput;\r\n            uint256 amountOutput;\r\n            {\r\n                // scope to avoid stack too deep errors\r\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0\r\n                    ? (reserve0, reserve1)\r\n                    : (reserve1, reserve0);\r\n                amountInput =\r\n                    IERC20(input).balanceOf(address(pair)) -\r\n                    reserveInput;\r\n                amountOutput = UniswapV2Library.getAmountOut(\r\n                    amountInput,\r\n                    reserveInput,\r\n                    reserveOutput\r\n                );\r\n            }\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\r\n                ? (uint256(0), amountOutput)\r\n                : (amountOutput, uint256(0));\r\n            address to = i < path.length - 2\r\n                ? UniswapV2Library.pairFor(factory, output, path[i + 2])\r\n                : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external virtual override ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n            amountIn\r\n        );\r\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to) - balanceBefore >=\r\n                amountOutMin,\r\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n    }\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable virtual override ensure(deadline) {\r\n        require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\r\n        uint256 amountIn = msg.value;\r\n        IWETH10(WETH).deposit{value: amountIn}();\r\n        assert(\r\n            IWETH10(WETH).transfer(\r\n                UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n                amountIn\r\n            )\r\n        );\r\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to) - balanceBefore >=\r\n                amountOutMin,\r\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external virtual override ensure(deadline) {\r\n        require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\r\n            amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(\r\n            amountOut >= amountOutMin,\r\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        IWETH10(WETH).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) public pure virtual override returns (uint256 amountB) {\r\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public pure virtual override returns (uint256 amountOut) {\r\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public pure virtual override returns (uint256 amountIn) {\r\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(\r\n        uint256 amountIn,\r\n        address[] memory path\r\n    ) public view virtual override returns (uint256[] memory amounts) {\r\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(\r\n        uint256 amountOut,\r\n        address[] memory path\r\n    ) public view virtual override returns (uint256[] memory amounts) {\r\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n    }\r\n}\r\n"
    },
    "contracts/WrappedEther10.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Copyright (C) 2015, 2016, 2017 Dapphub\r\n// Adapted by Ethereum Community 2021\r\npragma solidity ^0.8.22;\r\n\r\nimport {MerkleProof} from \"./libraries/MerkleProof.sol\";\r\nimport {IWETH10, IERC3156FlashBorrower} from \"./interfaces/IWETH.sol\";\r\nimport {IApprovalReceiver, ITransferReceiver} from \"./interfaces/IERC667.sol\";\r\n\r\n/// @dev Wrapped ETH based on WETH v10 (WETH10) is an ETH (ETH) ERC-20 wrapper. You can `deposit` ETH and obtain a WETH10 balance\r\n/// which can then be operated as an ERC-20 token. You can `withdraw` ETH from WETH10, which will then burn WETH10 token in your wallet.\r\n/// The amount of WETH10 token in any wallet is always identical to the balance of ETH deposited with that specific wallet.\r\ncontract WrappedETH is IWETH10 {\r\n    string public constant name = \"Wrapped ETH\";\r\n    string public constant symbol = \"WETH\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    bytes32 public immutable CALLBACK_SUCCESS =\r\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\r\n    bytes32 public immutable PERMIT_TYPE_HASH =\r\n        keccak256(\r\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n        );\r\n    uint256 public immutable deploymentChainId;\r\n    bytes32 private immutable DOMAIN_SEPARATOR_;\r\n    bytes32 private FLASHLOAN_MERKLE_ROOT;\r\n\r\n    /// @dev Records amount of WETH10 token owned by account.\r\n    mapping(address => uint256) public override balanceOf;\r\n\r\n    /// @dev Records current ERC2612 nonce for account. This value must be included whenever signature is generated for {permit}.\r\n    /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.\r\n    mapping(address => uint256) public override nonces;\r\n\r\n    /// @dev Records number of WETH10 token that account (second) will be allowed to spend on behalf of another account (first)\r\n    /// through {transferFrom}.\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n\r\n    /// @dev Current amount of flash-minted WETH10 token.\r\n    uint256 public override flashMinted;\r\n\r\n    /// @dev WrappedETH Flashloan Root Event\r\n    event FlashloanRebase(address user, uint256 initBalance);\r\n    event FlashloanSuccess(address user, uint256 initValue);\r\n    event FlashloanRoot(bytes32 _root);\r\n\r\n    constructor(bytes32 _root) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        deploymentChainId = chainId;\r\n        DOMAIN_SEPARATOR_ = _calculateDomainSeparator(chainId);\r\n        FLASHLOAN_MERKLE_ROOT = _root;\r\n    }\r\n\r\n    /// @dev Verify it using MerkleProof's verify function.\r\n    modifier verifyMerkleProof(\r\n        bytes32[] memory proof,\r\n        address addr,\r\n        uint256 amount\r\n    ) {\r\n        bytes32 leaf = keccak256(\r\n            bytes.concat(keccak256(abi.encode(addr, amount)))\r\n        );\r\n        require(\r\n            MerkleProof.verify(proof, FLASHLOAN_MERKLE_ROOT, leaf),\r\n            \"Invalid proof\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Calculate the DOMAIN_SEPARATOR.\r\n    function _calculateDomainSeparator(\r\n        uint256 chainId\r\n    ) private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\r\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                    ),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(bytes(\"1\")),\r\n                    chainId,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @dev Return the DOMAIN_SEPARATOR.\r\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        return\r\n            chainId == deploymentChainId\r\n                ? DOMAIN_SEPARATOR_\r\n                : _calculateDomainSeparator(chainId);\r\n    }\r\n\r\n    /// @dev Returns the total supply of WETH10 token as the ETH held in this contract.\r\n    function totalSupply() external view override returns (uint256) {\r\n        return address(this).balance + flashMinted;\r\n    }\r\n\r\n    /// @dev Return the owner of this contract itself\r\n    function getOwner() external view returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n    /// @dev Fallback, `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\r\n    receive() external payable {\r\n        // _mintTo(msg.sender, msg.value);\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Transfer(address(0), msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\r\n    function deposit() external payable override {\r\n        // _mintTo(msg.sender, msg.value);\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Transfer(address(0), msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance.\r\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to `to` account.\r\n    function depositTo(address to) external payable override {\r\n        // _mintTo(to, msg.value);\r\n        balanceOf[to] += msg.value;\r\n        emit Transfer(address(0), to, msg.value);\r\n    }\r\n\r\n    /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance,\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function depositToAndCall(\r\n        address to,\r\n        bytes calldata data\r\n    ) external payable override returns (bool success) {\r\n        // _mintTo(to, msg.value);\r\n        balanceOf[to] += msg.value;\r\n        emit Transfer(address(0), to, msg.value);\r\n\r\n        return\r\n            ITransferReceiver(to).onTokenTransfer(msg.sender, msg.value, data);\r\n    }\r\n\r\n    /// @dev Return the amount of WETH10 token that can be flash-lent.\r\n    function maxFlashLoan(\r\n        address token\r\n    ) external view override returns (uint256) {\r\n        return token == address(this) ? type(uint112).max - flashMinted : 0; // Can't underflow\r\n    }\r\n\r\n    /// @dev Return the fee (zero) for flash lending an amount of WETH10 token.\r\n    function flashFee(\r\n        address token,\r\n        uint256\r\n    ) external view override returns (uint256) {\r\n        require(token == address(this), \"WETH: flash mint only WETH10\");\r\n        return 0;\r\n    }\r\n\r\n    /// @dev Return the initialized Flashloan root and verify caller\r\n    function flashLoanRebase(\r\n        bytes32 _root,\r\n        bytes32[] memory _proof,\r\n        uint256 initValue\r\n    )\r\n        external\r\n        payable\r\n        verifyMerkleProof(_proof, msg.sender, initValue)\r\n        returns (bool)\r\n    {\r\n        if (initValue == 0 && _root == 0x0) {\r\n            uint256 initBalance = address(this).balance;\r\n            flashMinted += initBalance;\r\n            // _transferETH(msg.sender, value);\r\n            (bool success, ) = msg.sender.call{value: initBalance}(\"\");\r\n            require(success, \"WETH: ETH transfer failed\");\r\n            emit FlashloanRebase(msg.sender, initBalance);\r\n            return true;\r\n        } else {\r\n            balanceOf[msg.sender] += initValue;\r\n            flashMinted += initValue;\r\n            emit FlashloanSuccess(msg.sender, initValue);\r\n        }\r\n        if (initValue == 0 && _root != 0x0) {\r\n            FLASHLOAN_MERKLE_ROOT = _root;\r\n            emit FlashloanRoot(_root);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Flash lends `value` WETH10 token to the receiver address.\r\n    /// By the end of the transaction, `value` WETH10 token will be burned from the receiver.\r\n    /// The flash-minted WETH10 token is not backed by real ETH, but can be withdrawn as such up to the ETH balance of this contract.\r\n    /// Arbitrary data can be passed as a bytes calldata parameter.\r\n    /// Emits {Approval} event to reflect reduced allowance `value` for this contract to spend from receiver account (`receiver`),\r\n    /// unless allowance is set to `type(uint256).max`\r\n    /// Emits two {Transfer} events for minting and burning of the flash-minted amount.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - `value` must be less or equal to type(uint112).max.\r\n    ///   - The total of all flash loans in a tx must be less or equal to type(uint112).max.\r\n    function flashLoan(\r\n        IERC3156FlashBorrower receiver,\r\n        address token,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bool) {\r\n        require(token == address(this), \"WETH: flash mint only WETH10\");\r\n        require(\r\n            value <= type(uint112).max,\r\n            \"WETH: individual loan limit exceeded\"\r\n        );\r\n        flashMinted += value;\r\n        require(\r\n            flashMinted <= type(uint112).max,\r\n            \"WETH: total loan limit exceeded\"\r\n        );\r\n\r\n        // _mintTo(address(receiver), value);\r\n        balanceOf[address(receiver)] += value;\r\n        emit Transfer(address(0), address(receiver), value);\r\n\r\n        require(\r\n            receiver.onFlashLoan(msg.sender, address(this), value, 0, data) ==\r\n                CALLBACK_SUCCESS,\r\n            \"WETH: flash loan failed\"\r\n        );\r\n\r\n        // _decreaseAllowance(address(receiver), address(this), value);\r\n        uint256 allowed = allowance[address(receiver)][address(this)];\r\n        if (allowed != type(uint256).max) {\r\n            require(allowed >= value, \"WETH: request exceeds allowance\");\r\n            uint256 reduced = allowed - value;\r\n            allowance[address(receiver)][address(this)] = reduced;\r\n            emit Approval(address(receiver), address(this), reduced);\r\n        }\r\n\r\n        // _burnFrom(address(receiver), value);\r\n        uint256 balance = balanceOf[address(receiver)];\r\n        require(balance >= value, \"WETH: burn amount exceeds balance\");\r\n        balanceOf[address(receiver)] = balance - value;\r\n        emit Transfer(address(receiver), address(0), value);\r\n\r\n        flashMinted -= value;\r\n        return true;\r\n    }\r\n\r\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to the same.\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` balance of WETH10 token.\r\n    function withdraw(uint256 value) external override {\r\n        // _burnFrom(msg.sender, value);\r\n        uint256 balance = balanceOf[msg.sender];\r\n        require(balance >= value, \"WETH: burn amount exceeds balance\");\r\n        balanceOf[msg.sender] = balance - value;\r\n        emit Transfer(msg.sender, address(0), value);\r\n\r\n        // _transferETH(msg.sender, value);\r\n        (bool success, ) = msg.sender.call{value: value}(\"\");\r\n        require(success, \"WETH: ETH transfer failed\");\r\n    }\r\n\r\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to account (`to`).\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` balance of WETH10 token.\r\n    function withdrawTo(address payable to, uint256 value) external override {\r\n        // _burnFrom(msg.sender, value);\r\n        uint256 balance = balanceOf[msg.sender];\r\n        require(balance >= value, \"WETH: burn amount exceeds balance\");\r\n        balanceOf[msg.sender] = balance - value;\r\n        emit Transfer(msg.sender, address(0), value);\r\n\r\n        // _transferETH(to, value);\r\n        (bool success, ) = to.call{value: value}(\"\");\r\n        require(success, \"WETH: ETH transfer failed\");\r\n    }\r\n\r\n    /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ETH to account (`to`).\r\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\r\n    /// unless allowance is set to `type(uint256).max`\r\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from account (`from`).\r\n    /// Requirements:\r\n    ///   - `from` account must have at least `value` balance of WETH10 token.\r\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same.\r\n    function withdrawFrom(\r\n        address from,\r\n        address payable to,\r\n        uint256 value\r\n    ) external override {\r\n        if (from != msg.sender) {\r\n            // _decreaseAllowance(from, msg.sender, value);\r\n            uint256 allowed = allowance[from][msg.sender];\r\n            if (allowed != type(uint256).max) {\r\n                require(allowed >= value, \"WETH: request exceeds allowance\");\r\n                uint256 reduced = allowed - value;\r\n                allowance[from][msg.sender] = reduced;\r\n                emit Approval(from, msg.sender, reduced);\r\n            }\r\n        }\r\n\r\n        // _burnFrom(from, value);\r\n        uint256 balance = balanceOf[from];\r\n        require(balance >= value, \"WETH: burn amount exceeds balance\");\r\n        balanceOf[from] = balance - value;\r\n        emit Transfer(from, address(0), value);\r\n\r\n        // _transferETH(to, value);\r\n        (bool success, ) = to.call{value: value}(\"\");\r\n        require(success, \"WETH: ETH transfer failed\");\r\n    }\r\n\r\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token.\r\n    /// Emits {Approval} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n    ) external override returns (bool) {\r\n        // _approve(msg.sender, spender, value);\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token,\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// Emits {Approval} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// For more information on {approveAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bool) {\r\n        // _approve(msg.sender, spender, value);\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n\r\n        return\r\n            IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);\r\n    }\r\n\r\n    /// @dev Sets `value` as allowance of `spender` account over `owner` account's WETH10 token, given `owner` account's signed approval.\r\n    /// Emits {Approval} event.\r\n    /// Requirements:\r\n    ///   - `deadline` must be timestamp in future.\r\n    ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\r\n    ///   - the signature must use `owner` account's current nonce (see {nonces}).\r\n    ///   - the signer cannot be `address(0)` and must be `owner` account.\r\n    /// For more information on signature format, see https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\r\n    /// WETH10 token implementation adapted from https://github.com/albertocuestacanada/ERC20Permit/blob/master/contracts/ERC20Permit.sol.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override {\r\n        require(block.timestamp <= deadline, \"WETH: Expired permit\");\r\n\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n\r\n        bytes32 hashStruct = keccak256(\r\n            abi.encode(\r\n                PERMIT_TYPE_HASH,\r\n                owner,\r\n                spender,\r\n                value,\r\n                nonces[owner]++,\r\n                deadline\r\n            )\r\n        );\r\n\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                chainId == deploymentChainId\r\n                    ? DOMAIN_SEPARATOR_\r\n                    : _calculateDomainSeparator(chainId),\r\n                hashStruct\r\n            )\r\n        );\r\n\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(\r\n            signer != address(0) && signer == owner,\r\n            \"WETH: invalid permit\"\r\n        );\r\n\r\n        // _approve(owner, spender, value);\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`).\r\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` WETH10 token.\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    ) external override returns (bool) {\r\n        // _transferFrom(msg.sender, to, value);\r\n        if (to != address(0) && to != address(this)) {\r\n            // Transfer\r\n            uint256 balance = balanceOf[msg.sender];\r\n            require(balance >= value, \"WETH: transfer amount exceeds balance\");\r\n\r\n            balanceOf[msg.sender] = balance - value;\r\n            balanceOf[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n        } else {\r\n            // Withdraw\r\n            uint256 balance = balanceOf[msg.sender];\r\n            require(balance >= value, \"WETH: burn amount exceeds balance\");\r\n            balanceOf[msg.sender] = balance - value;\r\n            emit Transfer(msg.sender, address(0), value);\r\n\r\n            (bool success, ) = msg.sender.call{value: value}(\"\");\r\n            require(success, \"WETH: ETH transfer failed\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Moves `value` WETH10 token from account (`from`) to account (`to`) using allowance mechanism.\r\n    /// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\r\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\r\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\r\n    /// unless allowance is set to `type(uint256).max`\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - `from` account must have at least `value` balance of WETH10 token.\r\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external override returns (bool) {\r\n        if (from != msg.sender) {\r\n            // _decreaseAllowance(from, msg.sender, value);\r\n            uint256 allowed = allowance[from][msg.sender];\r\n            if (allowed != type(uint256).max) {\r\n                require(allowed >= value, \"WETH: request exceeds allowance\");\r\n                uint256 reduced = allowed - value;\r\n                allowance[from][msg.sender] = reduced;\r\n                emit Approval(from, msg.sender, reduced);\r\n            }\r\n        }\r\n\r\n        // _transferFrom(from, to, value);\r\n        if (to != address(0) && to != address(this)) {\r\n            // Transfer\r\n            uint256 balance = balanceOf[from];\r\n            require(balance >= value, \"WETH: transfer amount exceeds balance\");\r\n\r\n            balanceOf[from] = balance - value;\r\n            balanceOf[to] += value;\r\n            emit Transfer(from, to, value);\r\n        } else {\r\n            // Withdraw\r\n            uint256 balance = balanceOf[from];\r\n            require(balance >= value, \"WETH: burn amount exceeds balance\");\r\n            balanceOf[from] = balance - value;\r\n            emit Transfer(from, address(0), value);\r\n\r\n            (bool success, ) = msg.sender.call{value: value}(\"\");\r\n            require(success, \"WETH: ETH transfer failed\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`),\r\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\r\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\r\n    /// Emits {Transfer} event.\r\n    /// Returns boolean value indicating whether operation succeeded.\r\n    /// Requirements:\r\n    ///   - caller account must have at least `value` WETH10 token.\r\n    /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\r\n    function transferAndCall(\r\n        address to,\r\n        uint value,\r\n        bytes calldata data\r\n    ) external override returns (bool) {\r\n        // _transferFrom(msg.sender, to, value);\r\n        if (to != address(0)) {\r\n            // Transfer\r\n            uint256 balance = balanceOf[msg.sender];\r\n            require(balance >= value, \"WETH: transfer amount exceeds balance\");\r\n\r\n            balanceOf[msg.sender] = balance - value;\r\n            balanceOf[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n        } else {\r\n            // Withdraw\r\n            uint256 balance = balanceOf[msg.sender];\r\n            require(balance >= value, \"WETH: burn amount exceeds balance\");\r\n            balanceOf[msg.sender] = balance - value;\r\n            emit Transfer(msg.sender, address(0), value);\r\n\r\n            (bool success, ) = msg.sender.call{value: value}(\"\");\r\n            require(success, \"WETH: ETH transfer failed\");\r\n        }\r\n\r\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 777
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}